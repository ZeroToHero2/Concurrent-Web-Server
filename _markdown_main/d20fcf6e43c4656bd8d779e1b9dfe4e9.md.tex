\markdownRendererDocumentBegin
\markdownRendererHeadingOne{Overview}\markdownRendererInterblockSeparator
{}In this assignment, you will be developing a concurrent web server. To simplify this project, we are providing you with the code for a non-concurrent (but working) web server. This basic web server operates with only a single thread; it will be your job to make the web server multi-threaded so that it can handle multiple requests at the same time.\markdownRendererInterblockSeparator
{}The goals of this project are: - To learn the basic architecture of a simple web server - To learn how to add concurrency to a non-concurrent system - To learn how to read and modify an existing code base effectively\markdownRendererInterblockSeparator
{}Useful reading from \markdownRendererLink{OSTEP}{http://ostep.org}{http://ostep.org}{} includes: - \markdownRendererLink{Intro to threads}{http://pages.cs.wisc.edu/\markdownRendererTilde{}remzi/OSTEP/threads-intro.pdf}{http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf}{} - \markdownRendererLink{Using locks}{http://pages.cs.wisc.edu/\markdownRendererTilde{}remzi/OSTEP/threads-intro.pdf}{http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf}{} - \markdownRendererLink{Producer-consumer relationships}{http://pages.cs.wisc.edu/\markdownRendererTilde{}remzi/OSTEP/threads-cv.pdf}{http://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf}{} - \markdownRendererLink{Server concurrency architecture}{http://pages.cs.wisc.edu/\markdownRendererTilde{}remzi/OSTEP/threads-events.pdf}{http://pages.cs.wisc.edu/~remzi/OSTEP/threads-events.pdf}{}\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{HTTP Background}\markdownRendererInterblockSeparator
{}Before describing what you will be implementing in this project, we will provide a very brief overview of how a classic web server works, and the HTTP protocol (version 1.0) used to communicate with it; although web browsers and servers have \markdownRendererLink{evolved a lot over the years}{https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics\markdownRendererUnderscore{}of\markdownRendererUnderscore{}HTTP/Evolution\markdownRendererUnderscore{}of\markdownRendererUnderscore{}HTTP}{https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP}{}, the old versions still work and give you a good start in understanding how things work. Our goal in providing you with a basic web server is that you can be shielded from learning all of the details of network connections and the HTTP protocol needed to do the project; however, the network code has been greatly simplified and is fairly understandable should you choose to to study it.\markdownRendererInterblockSeparator
{}Classic web browsers and web servers interact using a text-based protocol called \markdownRendererStrongEmphasis{HTTP} (\markdownRendererStrongEmphasis{Hypertext Transfer Protocol}). A web browser opens a connection to a web server and requests some content with HTTP. The web server responds with the requested content and closes the connection. The browser reads the content and displays it on the screen.\markdownRendererInterblockSeparator
{}HTTP is built on top of the \markdownRendererStrongEmphasis{TCP/IP} protocol suite provided by the operating system. Together, TPC and IP ensure that messages are routed to their correct destination, get from source to destination reliably in the face of failure, and do not overly congest the network by sending too many messages at once, among other features. To learn more about networks, take a networking class (or many!), or read \markdownRendererLink{this free book}{https://book.systemsapproach.org}{https://book.systemsapproach.org}{}.\markdownRendererInterblockSeparator
{}Each piece of content on the web server is associated with a file in the server's file system. The simplest is \markdownRendererEmphasis{static} content, in which a client sends a request just to read a specific file from the server. Slightly more complex is \markdownRendererEmphasis{dynamic} content, in which a client requests that an executable file be run on the web server and its output returned to the client. Each file has a unique name known as a \markdownRendererStrongEmphasis{URL} (\markdownRendererStrongEmphasis{Universal Resource Locator}). \markdownRendererInterblockSeparator
{}As a simple example, let's say the client browser wants to fetch static content (i.e., just some file) from a web server running on some machine. The client might then type in the following URL to the browser: \markdownRendererCodeSpan{http://www.cs.wisc.edu/index.html}. This URL identifies that the HTTP protocol is to be used, and that an HTML file in the root directory (\markdownRendererCodeSpan{/}) of the web server called \markdownRendererCodeSpan{index.html} on the host machine \markdownRendererCodeSpan{www.cs.wisc.edu} should be fetched.\markdownRendererInterblockSeparator
{}The web server is not just uniquely identified by which machine it is running on but also the \markdownRendererStrongEmphasis{port} it is listening for connections upon. Ports are a communication abstraction that allow multiple (possibly independent) network communications to happen concurrently upon a machine; for example, the web server might be receiving an HTTP request upon port 80 while a mail server is sending email out using port 25. By default, web servers are expected to run on port 80 (the well-known HTTP port number), but sometimes (as in this project), a different port number will be used. To fetch a file from a web server running at a different port number (say 8000), specify the port number directly in the URL, e.g., \markdownRendererCodeSpan{http://www.cs.wisc.edu:8000/index.html}.\markdownRendererInterblockSeparator
{}URLs for executable files (i.e., dynamic content) can include program arguments after the file name. For example, to just run a program (\markdownRendererCodeSpan{test.cgi}) without any arguments, the client might use the URL \markdownRendererCodeSpan{http://www.cs.wisc.edu/test.cgi}. To specify more arguments, the \markdownRendererCodeSpan{?} and \markdownRendererCodeSpan{\markdownRendererAmpersand{}} characters are used, with the \markdownRendererCodeSpan{?} character to separate the file name from the arguments and the \markdownRendererCodeSpan{\markdownRendererAmpersand{} character to separate each argument from the others.  For
example,}http://www.cs.wisc.edu/test.cgi?x=10\markdownRendererAmpersand{}y=20\markdownRendererCodeSpan{can be used to send
multiple arguments}x\markdownRendererCodeSpan{and}y\markdownRendererCodeSpan{and their respective values to the program
}test.cgi\markdownRendererCodeSpan{. The program being run is called a **CGI program** (short for
[Common Gateway
Interface](https://en.wikipedia.org/wiki/Common\markdownRendererUnderscore{}Gateway\markdownRendererUnderscore{}Interface); yes, this
is a terrible name); the arguments are passed into the program as part of the
[}QUERY\markdownRendererEmphasis{STRING`](https://en.wikipedia.org/wiki/Query}string) environment variable, which the program can then parse to access these arguments.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{The HTTP Request}\markdownRendererInterblockSeparator
{}When a client (e.g., a browser) wants to fetch a file from a machine, the process starts by sending a machine a message. But what exactly is in the body of that message? These \markdownRendererEmphasis{request contents}, and the subsequent \markdownRendererEmphasis{reply contents}, are specified precisely by the HTTP protocol.\markdownRendererInterblockSeparator
{}Let's start with the request contents, sent from the web browser to the server. This HTTP request consists of a request line, followed by zero or more request headers, and finally an empty text line. A request line has the form: \markdownRendererCodeSpan{method uri version}. The \markdownRendererCodeSpan{method} is usually \markdownRendererCodeSpan{GET}, which tells the web server that the client simply wants to read the specified file; however, other methods exist (e.g., \markdownRendererCodeSpan{POST}). The \markdownRendererCodeSpan{uri} is the file name, and perhaps optional arguments (in the case of dynamic content). Finally, the \markdownRendererCodeSpan{version} indicates the version of the HTTP protocol that the web client is using (e.g., HTTP/1.0).\markdownRendererInterblockSeparator
{}The HTTP response (from the server to the browser) is similar; it consists of a response line, zero or more response headers, an empty text line, and finally the interesting part, the response body. A response line has the form version \markdownRendererCodeSpan{status message}. The \markdownRendererCodeSpan{status} is a three-digit positive integer that indicates the state of the request; some common states are \markdownRendererCodeSpan{200} for \markdownRendererCodeSpan{OK}, \markdownRendererCodeSpan{403} for \markdownRendererCodeSpan{Forbidden} (i.e., the client can't access that file), and \markdownRendererCodeSpan{404} for \markdownRendererCodeSpan{File Not Found} (the famous error). Two important lines in the header are \markdownRendererCodeSpan{Content-Type}, which tells the client the type of the content in the response body (e.g., HTML or gif or otherwise) and \markdownRendererCodeSpan{Content-Length}, which indicates the file size in bytes.\markdownRendererInterblockSeparator
{}For this project, you don't really need to know this information about HTTP unless you want to understand the details of the code we have given you. You will not need to modify any of the procedures in the web server that deal with the HTTP protocol or network connections. However, it's always good to learn more, isn't it?\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{A Basic Web Server}\markdownRendererInterblockSeparator
{}The code for the web server is available in this repository. You can compile the files herein by simply typing \markdownRendererCodeSpan{make}. Compile and run this basic web server before making any changes to it! \markdownRendererCodeSpan{make clean} removes .o files and executables and lets you do a clean build.\markdownRendererInterblockSeparator
{}When you run this basic web server, you need to specify the port number that it will listen on; ports below number 1024 are \markdownRendererEmphasis{reserved} (see the list \markdownRendererLink{here}{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml}{https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml}{}) so you should specify port numbers that are greater than 1023 to avoid this reserved range; the max is 65535. Be wary: if running on a shared machine, you could conflict with others and thus have your server fail to bind to the desired port. If this happens, try a different number!\markdownRendererInterblockSeparator
{}When you then connect your web browser to this server, make sure that you specify this same port. For example, assume that you are running on \markdownRendererCodeSpan{bumble21.cs.wisc.edu} and use port number 8003; copy your favorite HTML file to the directory that you start the web server from. Then, to view this file from a web browser (running on the same or a different machine), use the url \markdownRendererCodeSpan{bumble21.cs.wisc.edu:8003/favorite.html}. If you run the client and web server on the same machine, you can just use the hostname \markdownRendererCodeSpan{localhost} as a convenience, e.g., \markdownRendererCodeSpan{localhost:8003/favorite.html}.\markdownRendererInterblockSeparator
{}To make the project a bit easier, we are providing you with a minimal web server, consisting of only a few hundred lines of C code. As a result, the server is limited in its functionality; it does not handle any HTTP requests other than \markdownRendererCodeSpan{GET}, understands only a few content types, and supports only the \markdownRendererCodeSpan{QUERY\markdownRendererUnderscore{}STRING} environment variable for CGI programs. This web server is also not very robust; for example, if a web client closes its connection to the server, it may trip an assertion in the server causing it to exit. We do not expect you to fix these problems (though you can, if you like, you know, for fun).\markdownRendererInterblockSeparator
{}Helper functions are provided to simplify error checking. A wrapper calls the desired function and immediately terminate if an error occurs. The wrappers are found in the file \markdownRendererCodeSpan{io-helper.h}); more about this below. One should always check error codes, even if all you do in response is exit; dropping errors silently is \markdownRendererStrongEmphasis{BAD C PROGRAMMING} and should be avoided at all costs.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{Finally: Some New Functionality!}\markdownRendererInterblockSeparator
{}In this project, you will be providing following deliverables. You'll be mainly working in wserver.c, other files are already implemented completely, you don't need to modify anything there. \markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Deliverable 1 : Protected Server}\markdownRendererInterblockSeparator
{}To begin modifying the server, you add a functionality to create a new process upon accepting a connection. For this task, you'll fork a child process, which will be responsible to serve the request. The parent process simply waits for child to finish, and then accepts new connection. This implementation would still be able to serve just one request, however, since you create a new process on every request, hence the server process is secured from any malicious attempt caused by a request. Please refer to lecture slide 6.44, 6.45 for this implementation.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Deliverable 2 : Concurrent and Protected Server}\markdownRendererInterblockSeparator
{}You can make the server concurrent i.e. it can serve more than one request concurrently. For this task, you'll modify the code of Deliverabl 1, so that parent process shouldn't wait for completion of the child, rather it simply goes to accepting more connections. Please refer to lecture slide 6.47, 6.48 for this implemenation. \markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Deliverable 3 : Multi-threaded Server}\markdownRendererInterblockSeparator
{}Creating a new process on every request is too heavy, as we create a new process every time. A thread creation is a lighter operation as compared to creating a process. The simplest approach to building a multi-threaded server is to spawn a new thread for every new http request. The OS will then schedule these threads according to its own policy. The advantage of creating these threads is that now short requests will not need to wait for a long request to complete; further, when one thread is blocked (i.e., waiting for disk I/O to finish) the other threads can continue to handle other requests. Please refer to lecture slide 6.52 for this implementation. \markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Deliverable 4 : Worker Threads}\markdownRendererInterblockSeparator
{}so far the server is set to be multi-threaded, however, server pays the cost of creating a new thread upon every request. Therefore, the generally preferred approach for a multi-threaded server is to create a fixed-size \markdownRendererEmphasis{pool} of worker threads when the web server is first started. With the pool-of-threads approach, each thread is blocked until there is an http request for it to handle. Therefore, if there are more worker threads than active requests, then some of the threads will be blocked, waiting for new HTTP requests to arrive; if there are more requests than worker threads, then those requests will need to be buffered until there is a ready thread. Please refer to lecture slide 6.53 for this idea.\markdownRendererInterblockSeparator
{}In your implementation, you must have a master thread that begins by creating a pool of worker threads, the number of which is specified on the command line. Your master thread is then responsible for accepting new HTTP connections over the network and placing the descriptor for this connection into a fixed-size buffer; in your basic implementation, the master thread should not read from this connection. The number of elements in the buffer is also specified on the command line. Note that the existing web server has a single thread that accepts a connection and then immediately handles the connection; in your web server, this thread should place the connection descriptor into a fixed-size buffer and return to accepting more connections.\markdownRendererInterblockSeparator
{}Each worker thread is able to handle both static and dynamic requests. A worker thread wakes when there is an HTTP request in the queue; when there are multiple HTTP requests available, which request is handled depends upon the scheduling policy. There could be various scheduling policies at this level, as we learned for CPU scheduling, however, you can implement FCFS scheduling for your implementation. Once the worker thread wakes, it performs the read on the network descriptor, obtains the specified content (by either reading the static file or executing the CGI process), and then returns the content to the client by writing to the descriptor. The worker thread then waits for another HTTP request.\markdownRendererInterblockSeparator
{}Note that the master thread and the worker threads are in a producer-consumer relationship and require that their accesses to the shared buffer be synchronized. Specifically, the master thread must block and wait if the buffer is full; a worker thread must wait if the buffer is empty. In this project, you are required to use condition variables. Note: if your implementation performs any busy-waiting (or spin-waiting) instead, you will be heavily penalized.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Command-line Parameters}\markdownRendererInterblockSeparator
{}Your C program must be invoked exactly as follows:\markdownRendererInterblockSeparator
{}\markdownRendererCodeSpan{sh
prompt> ./wserver [-d basedir] [-p port] [-t threads] [-b buffers] 
}\markdownRendererInterblockSeparator
{}The command line arguments to your web server are to be interpreted as follows.\markdownRendererInterblockSeparator
{}\markdownRendererUlBeginTight
\markdownRendererUlItem \markdownRendererStrongEmphasis{basedir}: this is the root directory from which the web server should operate. The server should try to ensure that file accesses do not access files above this directory in the file-system hierarchy. Default: current working directory (e.g., \markdownRendererCodeSpan{.}).\markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererStrongEmphasis{port}: the port number that the web server should listen on; the basic web server already handles this argument. Default: 10000.\markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererStrongEmphasis{threads}: the number of worker threads that should be created within the web server. Must be a positive integer. Default: 1.\markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererStrongEmphasis{buffers}: the number of request connections that can be accepted at one time. Must be a positive integer. Note that it is not an error for more or less threads to be created than buffers. Default: 1.\markdownRendererUlItemEnd 
\markdownRendererUlEndTight \markdownRendererInterblockSeparator
{}For example, you could run your program as: \markdownRendererCodeSpan{
prompt> ./wserver -p 8003 -t 8 -b 16 
}\markdownRendererInterblockSeparator
{}In this case, your web server will listen to port 8003, create 8 worker threads for handling HTTP requests, allocate 16 buffers for connections that are currently in progress (or waiting).\markdownRendererInterblockSeparator
{}\markdownRendererHeadingOne{Source Code Overview}\markdownRendererInterblockSeparator
{}We recommend understanding how the code that we gave you works. We provide the following files:\markdownRendererInterblockSeparator
{}\markdownRendererUlBeginTight
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{wserver.c}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/wserver.c}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/wserver.c}{}: Contains \markdownRendererCodeSpan{main()} for the web server and the basic serving loop.\markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{request.c}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/request.c}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/request.c}{}: Performs most of the work for handling requests in the basic web server. Start at \markdownRendererCodeSpan{request\markdownRendererUnderscore{}handle()} and work through the logic from there. \markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{io\markdownRendererUnderscore{}helper.h}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/io\markdownRendererUnderscore{}helper.h}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/io_helper.h}{} and \markdownRendererLink{\markdownRendererCodeSpan{io\markdownRendererUnderscore{}helper.c}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/io\markdownRendererUnderscore{}helper.c}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/io_helper.c}{}: Contains wrapper functions for the system calls invoked by the basic web server and client. The convention is to add \markdownRendererCodeSpan{\markdownRendererUnderscore{}or\markdownRendererUnderscore{}die} to an existing call to provide a version that either succeeds or exits. For example, the \markdownRendererCodeSpan{open()} system call is used to open a file, but can fail for a number of reasons. The wrapper, \markdownRendererCodeSpan{open\markdownRendererUnderscore{}or\markdownRendererUnderscore{}die()}, either successfully opens a file or exists upon failure. \markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{wclient.c}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/wclient.c}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/wclient.c}{}: Contains main() and the support routines for the very simple web client. To test your server, you may want to change this code so that it can send simultaneous requests to your server. By launching \markdownRendererCodeSpan{wclient} multiple times, you can test how your server handles concurrent requests.\markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{spin.c}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/spin.c}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/spin.c}{}: A simple CGI program. Basically, it spins for a fixed amount of time, which you may useful in testing various aspects of your server. \markdownRendererUlItemEnd 
\markdownRendererUlItem \markdownRendererLink{\markdownRendererCodeSpan{Makefile}}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/Makefile}{https://github.com/remzi-arpacidusseau/ostep-projects/blob/master/concurrency-webserver/src/Makefile}{}: We also provide you with a sample Makefile that creates \markdownRendererCodeSpan{wserver}, \markdownRendererCodeSpan{wclient}, and \markdownRendererCodeSpan{spin.cgi}. You can type make to create all of these programs. You can type make clean to remove the object files and the executables. You can type make server to create just the server program, etc. As you create new files, you will need to add them to the Makefile.\markdownRendererUlItemEnd 
\markdownRendererUlEndTight \markdownRendererInterblockSeparator
{}The best way to learn about the code is to compile it and run it. Run the server we gave you with your preferred web browser. Run this server with the client code we gave you. You can even have the client code we gave you contact any other server that speaks HTTP. Make small changes to the server code (e.g., have it print out more debugging information) to see if you understand how it works.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Additional Useful Reading}\markdownRendererInterblockSeparator
{}We anticipate that you will find the following routines useful for creating and synchronizing threads: \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}create()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}mutex\markdownRendererUnderscore{}init()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}mutex\markdownRendererUnderscore{}lock()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}mutex\markdownRendererUnderscore{}unlock()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}cond\markdownRendererUnderscore{}init()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}cond\markdownRendererUnderscore{}wait()}, \markdownRendererCodeSpan{pthread\markdownRendererUnderscore{}cond\markdownRendererUnderscore{}signal()}. To find information on these library routines, read the man pages (RTFM). \markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Sample Execution}\markdownRendererInterblockSeparator
{}You can run the server by opening folder in vscode and navigate to \markdownRendererCodeSpan{src} folder. Now compile the program by:\markdownRendererInterblockSeparator
{}make\markdownRendererInterblockSeparator
{}Run the server by:\markdownRendererInterblockSeparator
{}./wserver -p 2022 -t 2 -b 5\markdownRendererInterblockSeparator
{}Now open your web browser and go the address:\markdownRendererInterblockSeparator
{}127.0.0.1:2022\markdownRendererInterblockSeparator
{}It'll simply display a welcome message. This is a short job, doesn't require a lot of time on server to serve it. For a longer job, you can request this page:\markdownRendererInterblockSeparator
{}127.0.0.1:2022/spin.cgi?10\markdownRendererInterblockSeparator
{}It'll take 10 seconds on server to serve this job. Change the value after ? to spin the server for desired time.\markdownRendererInterblockSeparator
{}\markdownRendererHeadingTwo{Acknowledgement}\markdownRendererInterblockSeparator
{}This homework is adapted from \markdownRendererStrongEmphasis{OSTEP: Operating Systems Three Easy Parts} by Remzi et al. at University of Wisconsin-Madison.\markdownRendererDocumentEnd